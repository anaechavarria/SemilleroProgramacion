\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{listings}

\setbeamercovered{invisible}
\usetheme{Frankfurt}
\usefonttheme{serif}

% Configurar los listings (Códigos)
\renewcommand{\lstlistingname}{Código}
\lstset{
	language=C++,               % Lenguaje
	basicstyle=\ttfamily\tiny,  % Tipo de fuente
	keywordstyle=\color{blue},  % Color de palabras clave
	stringstyle=\color{red},    % Color de strings
	commentstyle=\color{gray},  % Color de comentarios
	showstringspaces=false,     % No muestrar el _ cuando el string tiene espacios
	breaklines = true,          % Partir las líneas largas
	breakatwhitespace=true,	    % Partir las líneas en un espacio
	numbers=left,				% Numerar las líneas a la izq
	numberstyle=\tiny,			% Poner los números de las líneas pequeños
	numberblanklines=true,      % Numerar las líneas en blanco
	columns=fullflexible,       % No perder el formato al dejar los espacios
	keepspaces=true,   			% Dejar los espacios insertados
	frame=tb,					% Poner el recuadro
}


\title{Semillero de Programación}
\subtitle{Arreglos, Vectores y Grafos}
\author{Ana Echavarría \and Juan Francisco Cardona}

\institute{Universidad EAFIT}
\date{8 de febrero de 2013}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Contenido}
	\tableofcontents
\end{frame}


\begin{section}{Arreglos de C++}
	\begin{frame}[fragile]
		\frametitle{Arreglos de C++}
		\begin{itemize}
			\item{Un arreglo es una serie de elementos del mismo tipo ordenados en una secuencia lineal.}
			\item{El número de elementos del arreglo es fijo.}
			\item{Se puede acceder a cada elemento de manera individual usando el índice de su posición, empezando por el índice 0.}
			\item{Por ejemplo, un arreglo de 10 posiciones llamado $a$ puede ser representado así:}
			\begin{figure}
				\includegraphics[width = 0.7\textwidth]{arreglo.jpg}
			\end{figure}			
		\end{itemize}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Arreglos de C++}
		Un arreglo debe ser declarado antes de usarse. Para declararse se hace lo siguiente.
		\begin{block}{Declaración de arreglos}
			\begin{verbatim}
				tipo_de_dato nombre [número_de_elementos];
			\end{verbatim}
			Ejemplos:\\
			\begin{verbatim}
				int a [10];
				string palabras [50];
			\end{verbatim}			
		\end{block}		
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Arreglos de C++}
		Se pueden declarar arreglos de varias dimensiones
		\begin{block}{Arreglos de varias dimensiones}
			\begin{verbatim}
				tipo_de_dato nombre [tam_dim_1] ... [tam_dim_n];
			\end{verbatim}
			Ejemplo:
			\begin{verbatim}
				int jimmy [3][5];
			\end{verbatim}	
		\end{block}
		\begin{figure}
			\includegraphics[width = 0.8\textwidth]{arreglo2.png}
		\end{figure}		
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Arreglos de C++}
		\small{El problema Next Round se puede resolver usando arreglos (http://www.codeforces.com/problemset/problem/158/A)}
		\begin{lstlisting}
			using namespace std;
			#include <iostream>

			const int MAXN = 55;
			int a [MAXN];

			int main(){
			    int n, k;
			    cin >> n >> k;
			    for (int i = 0; i < n; i++) cin >> a[i];

			    int count = 0;
			    int min_score = a[k-1];
			    for (int i = 0; i < n; i++){
			        if (a[i] >= min_score and a[i] > 0) count++;
			        else break;
			    }
			    cout << count << endl;
			    
				return 0;
			}
		\end{lstlisting}		
	\end{frame}	
\end{section}

\begin{section}{Vectores de C++}
	\begin{frame}[fragile]
		\frametitle{Vectores de C++}
		\begin{itemize}
			\item {Los vectores son contenedores que almacenan los datos en una secuencia pero que pueden cambiar de tamaño.}
			\item {Al igual que los arreglos, los elementos pueden ser accedidos por medio del índice de su posición, empezando por en índice 0.}
			\item {Contrario a los arreglos, el tamaño de los vectores cambia dinámicamente. Esto hace que utilicen más memoria para poder crecer eficientemente.}
		\end{itemize}
		\begin{figure}
			\includegraphics[width = 0.8\textwidth]{vector.jpg}
		\end{figure}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Vectores de C++}
		Para utilizar un vector es necesario incluir la librería vector.\\
		\verb|#include <vector> |
		\begin{block}{Declaración de vector}
			\begin{verbatim}
				vector <tipo_de_dato> nombre;
			\end{verbatim}
			Ejemplos:\\
			\begin{verbatim}
				vector <int> a;
				vector <string> palabras (50);
				vector <int> zeros (500, 0);
			\end{verbatim}			
		\end{block}		
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Vectores de C++}
		\small{El problema Next Round se puede resolver usando vectores (http://www.codeforces.com/problemset/problem/158/A)}
		\begin{lstlisting}
			using namespace std;
			#include <iostream>
			#include <vector>

			vector <int> a;

			int main(){
			    int n, k;
			    cin >> n >> k;
			    a.clear();
			    for (int i = 0; i < n; i++){
			        int ai;
			        cin >> ai;
			        a.push_back(ai); 
			    }

			    int count = 0;
			    int min_score = a[k-1];
			    for (int i = 0; i < n; i++){
			        if (a[i] >= min_score and a[i] > 0) count++;
			        else break;
			    }
			    cout << count << endl;
			    
				return 0;
			}
		\end{lstlisting}		
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Arreglos y vectores en C++}
		\begin{alertblock}{Pregunta}
			¿Qué significa \verb|vector <int> g [1000]|? 
		\end{alertblock}\pause
		\begin{exampleblock}{Respuesta}
			Es un arreglo de 1000 posiciones en el que cada posición contiene un vector de enteros
		\end{exampleblock}
	\end{frame}	
\end{section}

\begin{section}{Grafos}
	\begin{frame}
		\frametitle{Grafos dirigidos}
		Un grafo dirigido $G$ es un par $(V, E)$ donde $V$ es un conjunto finito de \textbf{nodos} (vertices) y $E$ es un conjunto de \textbf{parejas ordenadas} donde cada elemento es un elemento de $V$ y es llamado conjunto de \textbf{aristas} (edges).\\
		En la siguiente figura $V = \{1, 2, 3, 4, 5, 6\}$ y $E = \{(1, 2), (2, 2), (2, 4), (2, 5), (4, 1), (4, 5), (5, 4), (6, 3)\}$
		\begin{figure}
			\includegraphics[height = 0.35\textheight]{digraph.png}
		\end{figure}		
	\end{frame}
	
	\begin{frame}
		\frametitle{Grafos no dirigidos}
		En un grafo no dirigido $G = (V, E)$, $V$ es un conjunto finito de \textbf{nodos} (vertices) y $E$ es un conjunto de \textbf{parejas no ordenadas} $(u, v)$ donde $u, v \in V$ y $u \ne v$.\\
		En la siguiente figura $V = \{1, 2, 3, 4, 5, 6\}$ y $E = \{(1, 2), (1, 5), (2, 5), (6, 3)\}$
		\begin{figure}
			\includegraphics[height = 0.35\textheight]{graph.png}
		\end{figure}		
	\end{frame}
	
	\begin{frame}
		\frametitle{Representación de grafos}
		Hay dos formas de representar los grafos (tanto dirigidos como no dirigidos) con una matriz de adyacencia o con una lista de ayacencia.\\
		La lista de adyacencia es más comúnmente usada porque usa menos memoria que la matriz de adyacencia.
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Matriz de adyacencia}
		La representación de un grafo $G = (V, E)$ como matriz de adyacencia consiste en una matriz $M$ de tamaño $|V| \cdot |V|$ donde se asume que los nodos están numerados de $0 \ldots |V|$. La matriz de adyacencia se define así:
		\begin{equation}
			M[u][v] =
			\left\{
				\begin{array}{ll}
					1 & \mbox{si } (u, v) \in E \mbox{ o} \\
					  & \mbox{si } (v, u) \in E \mbox{ para grafos no dirigidos}\\
					0 & \mbox{en caso contrario.} 
				\end{array}
			\right.
		\end{equation}
		Esto quiere decir que la matriz contiene un 1 si $u$ es adyacente a $v$ y un 0 si no lo es.
	\end{frame}
	
	\begin{frame}
		\frametitle{Matriz de adyacencia}
		\begin{alertblock}{Pregunta}
			¿Cuánto espacio requiere la representación de matriz de adyacencia para un grafo $G = (V, E)$?
		\end{alertblock}\pause
		\begin{exampleblock}{Respuesta}
			$|V|^2$, se necesita una matriz de tamaño $|V| \cdot |V|$.
		\end{exampleblock}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Lista de adyacencia}
		La representación de un grafo $G = (V, E)$ como lista de ayacencia consiste en un arreglo $Adj$ de $|V|$ vectores.\\ \quad \\
		Para cada $u \in V$, $Adj[u]$ contiene una lista (vector) con todos los elementos $v \in V$ tales que $(u, v) \in E$, es decir, todos los nodos adyacentes a $u$. \\ \quad \\
		En los grafos no dirigidos, dada la arista $(u, v)$ se agregaría $v$ a $Adj[u]$ y $u$ a $Adj[v]$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Lista de adyacencia}
		\begin{alertblock}{Pregunta}
			¿Cuánto espacio requiere la representación de lista de adyacencia para un grafo $G = (V, E)$?
		\end{alertblock}\pause
		\begin{exampleblock}{Respuesta}
			\begin{itemize}
				\item{$|E|$ para grafos dirigidos. Por cada arista se agrega un valor nuevo a la lista de adyacencia.}
				\item{$2 \cdot |E|$ para grafos no dirigidos. Por cada arista se agregan dos valores a la lista de adyacencia.}
			\end{itemize}
		\end{exampleblock}
	\end{frame}
	
	\begin{frame}
		\frametitle{Lista de adyacencia vs. Matriz de adyacencia}
		\begin{itemize}
			\item{La representación como lista de adyacencia es más común en grafos dispersos, cuando el número de aristas es pequeño ($|E|$ es mucho menor que $|V|^2$).}
			\item{La representación como matriz de adyacencia es más común en grafos densos, cuando el número de aritas es grande ($|E|$ es cercano a $|V|^2$).}
			\item{Verificar si dos nodos están conectados en un la matriz de adyacencia es más fácil que hacerlo en la lista de adyacencia.} %Preguntarles que vean por qué.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Ejercicio}
		Representar el siguiente grafo dirigido por medio de su matriz de adyacencia y su lista de adyacencia.
		\begin{figure}
			\includegraphics[height = 0.3\textheight]{ejemplo_digraph.png}
		\end{figure}
		\pause
		\begin{columns}
			\column{.45\textwidth}
				\includegraphics[height = 0.3\textheight]{lista_digraph.png}
			\column{.40\textwidth}
				\includegraphics[height = 0.3\textheight]{matriz_digraph.png}
		\end{columns}		
	\end{frame}
	
	\begin{frame}
		\frametitle{Ejercicio}
		Representar el siguiente grafo no dirigido por medio de su matriz de adyacencia y su lista de adyacencia.
		\begin{figure}
			\includegraphics[height = 0.3\textheight]{ejemplo_graph.png}
		\end{figure}
		\pause
		\begin{columns}
			\column{.45\textwidth}
				\includegraphics[height = 0.3\textheight]{lista_graph.png}
			\column{.40\textwidth}
				\includegraphics[height = 0.3\textheight]{matriz_graph.png}
		\end{columns}		
	\end{frame}

	\begin{frame}
		\frametitle{Tarea}
		\begin{alertblock}{Tarea 1.}
			Escrbir un programa que genere las representaciones como matriz y lista de adyacencia de un grafo \textbf{no dirigido} $G$.\\
			La primera línea de la entrada consiste de dos enteros $n$ el número de nodos y $m$ el número de aristas $(1 \leq n \leq 10$ y $1 \leq m \leq 100)$. Las siguientes $m$ líneas tienen cada una dos enteros $u$ y $v$ $(1 \leq u, v \leq n)$ que indican que hay una arista que une los nodos $u$ y $v$.
		\end{alertblock}
		
		\begin{alertblock}{Tarea 2.}
			Las representaciones que vimos son para grafos en los que las aristas no tienen pesos. ¿Cómo representarían grafos cuyas aristas tienen pesos?\\
			Pista: Pensar primero cómo lo harían usando la matriz de adyacencia y luego la lista de adyacencia.
		\end{alertblock}
	\end{frame}
	
	\begin{frame}
		\frametitle{La próxima clase}
		La próxima clase veremos dos métodos para recorrer grafos.
		\begin{itemize}
			\item {BFS (Breath First Search)}
			\item {DFS (Depth First Search)}
		\end{itemize}
	\end{frame}
	
	
\end{section}

\end{document}